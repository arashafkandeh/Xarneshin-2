<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>{{ page_title if page_title else "Inbound Editor" }}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">
  
  <!-- CodeMirror CSS/JS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.9/lib/codemirror.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.9/theme/dracula.min.css">
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.9/lib/codemirror.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.9/mode/javascript/javascript.min.js"></script>
  
  <!-- Vue 3 -->
  <script src="https://cdn.jsdelivr.net/npm/vue@3.2.47/dist/vue.global.min.js"></script>
  
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
  
  <style>
    /* Global & Futuristic Styling */
    body {
      background: linear-gradient(135deg, #0d1b2a, #1b263b);
      color: #e0e7ff;
      font-family: 'Orbitron', 'Roboto', sans-serif;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }
    .container {
      max-width: 100%;
      padding: 2rem;
      backdrop-filter: blur(10px);
      background: rgba(27, 38, 59, 0.1);
    }
  
    /* Card Styling with Glassmorphism */
    .card {
      background: rgba(27, 38, 59, 0.7);
      border: 1px solid rgba(167, 139, 250, 0.3);
      border-radius: 1.5rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), inset 0 0 10px rgba(167, 139, 250, 0.1);
      margin-bottom: 1.5rem;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6), inset 0 0 15px rgba(167, 139, 250, 0.2);
    }
    .card-body {
      padding: 2rem;
    }
    .form-label {
      font-weight: 600;
      color: #a5b4fc;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
  
    /* Form Controls with Neon Glow */
    .form-control, .form-select, textarea.form-control {
      background: rgba(30, 42, 65, 0.8);
      border: 1px solid rgba(167, 139, 250, 0.5);
      color: #e0e7ff;
      border-radius: 0.75rem;
      padding: 0.75rem;
      transition: border-color 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
    }
    .form-control:focus, .form-select:focus {
      background: rgba(30, 42, 65, 0.9);
      border-color: #a78bfa;
      box-shadow: 0 0 15px rgba(167, 139, 250, 0.7);
      color: #e0e7ff;
      outline: none;
    }
    .form-control::placeholder {
      color: rgba(165, 180, 252, 0.7);
      opacity: 1;
    }
  
    /* Button Styling with Neon Effect */
    .btn-teal {
      background: linear-gradient(45deg, #06b6d4, #0f766e);
      color: #fff;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
      transition: all 0.3s ease;
    }
    .btn-teal:hover {
      background: linear-gradient(45deg, #0f766e, #06b6d4);
      box-shadow: 0 0 20px rgba(6, 182, 212, 0.8);
      transform: scale(1.05);
    }
  
    /* Nav Pills for Certificate Mode */
    .nav-pills .nav-link {
      border-radius: 9999px;
      font-weight: 600;
      padding: 0.75rem 1.5rem;
      margin-right: 0.75rem;
      background: rgba(26, 39, 51, 0.8);
      border: 1px solid rgba(167, 139, 250, 0.4);
      color: #a5b4fc;
      transition: all 0.3s ease;
    }
    .nav-pills .nav-link.active {
      background: linear-gradient(45deg, #9333ea, #a78bfa);
      border-color: transparent;
      color: #fff;
      box-shadow: 0 0 15px rgba(167, 139, 250, 0.7);
    }
  
    /* Tabs Styling */
    .nav-tabs {
      border-bottom: none;
    }
    .nav-tabs .nav-link {
      background: rgba(26, 39, 51, 0.7);
      border: 1px solid rgba(167, 139, 250, 0.3);
      margin: 0 0.5rem;
      min-width: 120px;
      text-align: center;
      border-radius: 1rem 1rem 0 0;
      color: #a5b4fc;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    .nav-tabs .nav-link.active {
      background: rgba(167, 139, 250, 0.2);
      border-bottom: none;
      color: #fff !important;
      box-shadow: 0 0 15px rgba(167, 139, 250, 0.5);
    }
  
    /* CodeMirror Overrides */
    .CodeMirror {
      border: 1px solid rgba(167, 139, 250, 0.5);
      font-size: 1rem;
      border-radius: 1rem;
      background: rgba(30, 42, 65, 0.9);
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
    }
    .json-error {
      color: #ff6b6b;
      margin-top: 0.5rem;
      font-weight: 500;
    }
    #jsonTabContent .CodeMirror {
      height: 70vh;
    }
  
    /* Additional Elements */
    h5, h6 {
      color: #c4b5fd;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      margin-bottom: 1.5rem;
    }
    .form-check-label {
      color: #a5b4fc;
    }
    .form-check-input:checked {
      background-color: #a78bfa;
      border-color: #a78bfa;
      box-shadow: 0 0 10px rgba(167, 139, 250, 0.5);
    }
    .table {
      color: #e0e7ff;
      background: rgba(30, 42, 65, 0.5);
      border-radius: 0.75rem;
      overflow: hidden;
    }
    .table th {
      background: rgba(167, 139, 250, 0.2);
      color: #e0e7ff;
      border: none;
    }
    .table td {
      border: none;
      border-top: 1px solid rgba(167, 139, 250, 0.2);
    }
  </style>
</head>
<script>
  (function() {
    const originalFetch = window.fetch;
    window.fetch = function(input, init) {
      if (typeof input === 'string') {
        input = input.replace(/\/+$/, '');
      } else if (input instanceof Request) {
        const newUrl = input.url.replace(/\/+$/, '');
        input = new Request(newUrl, input);
      }
      return originalFetch(input, init);
    };
  })();

  // Helper functions for password generation
  function generateBase64Password(byteLength) {
    const array = new Uint8Array(byteLength);
    crypto.getRandomValues(array);
    return btoa(String.fromCharCode(...array));
  }

  function generateAlphanumericPassword(length) {
    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const values = new Uint32Array(length);
    crypto.getRandomValues(values);
    let password = '';
    for (let i = 0; i < length; i++) {
      const randomIndex = values[i] % charset.length;
      password += charset[randomIndex];
    }
    return password;
  }
</script>
<body>
  <!-- Define global variables from Jinja before the Vue app -->
  <script>
    window.formActionUrl = "{{ formActionUrl }}";
    window.isEditMode = {{ 'true' if edit_mode else 'false' }};
    window.initialInboundData = {{ inbound_data_json|safe }};
  </script>
  
  <div id="app" class="container mx-auto">
    <!-- Navigation Tabs -->
    <ul class="nav nav-tabs" role="tablist">
      <li class="nav-item" role="presentation">
        <button class="nav-link" :class="{ active: currentTab==='form' }" @click="switchTab('form')" type="button" role="tab">
          Form Editor
        </button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" :class="{ active: currentTab==='json' }" @click="switchTab('json')" type="button" role="tab">
          JSON Editor
        </button>
      </li>
    </ul>
  
    <div class="tab-content">
      <!-- FORM TAB -->
      <div class="tab-pane" :class="[ currentTab==='form' ? 'active show' : '' ]" role="tabpanel">
        <!-- Header -->
        <div class="card mt-3">
          <div class="card-body">
            <h4 class="mb-0">[[ page_title ? page_title : "Inbound Form" ]]</h4>
          </div>
        </div>
  
        <!-- Basic Settings -->
        <div class="card">
          <div class="card-body">
            <h5>Basic Settings</h5>
            <div class="mb-3">
              <label class="form-label">Remark (Tag)</label>
              <input type="text" class="form-control" v-model="inboundData.tag">
            </div>
            <div class="mb-3">
              <label class="form-label">Protocol</label>
              <select class="form-select" v-model="inboundData.protocol">
                <option v-for="prot in protocols" :key="prot" :value="prot">
                  [[ prot.toUpperCase() ]]
                </option>
              </select>
            </div>
            <div class="mb-3">
              <label class="form-label">Listen (IP)</label>
              <input type="text" class="form-control" v-model="inboundData.listen">
            </div>
            <div class="mb-3">
              <label class="form-label">Port</label>
              <input type="number" class="form-control" v-model.number="inboundData.port" min="1" max="65535">
            </div>
          </div>
        </div>
  
        <!-- Shadowsocks Settings -->
        <div class="card" v-if="inboundData.protocol==='shadowsocks'">
          <div class="card-body">
            <h5>Shadowsocks Settings</h5>
            <div class="mb-3">
              <label class="form-label">Encryption Method</label>
              <select class="form-select" v-model="inboundData.settings.method" @change="regenerateSSPassword">
                <option v-for="m in ssMethods" :key="m" :value="m">[[ m ]]</option>
              </select>
            </div>
            <div class="mb-3">
              <label class="form-label">Password</label>
              <div class="input-group">
                <input type="text" class="form-control" v-model="inboundData.settings.password" readonly>
                <button class="btn btn-outline-secondary" type="button" @click="regenerateSSPassword">Regenerate</button>
              </div>
            </div>
            <div class="mb-3">
              <label class="form-label">First Network (for shadowsocks settings)</label>
              <select class="form-select" v-model="inboundData.settings.network">
                <option value="tcp">tcp</option>
                <option value="udp">udp</option>
                <option value="tcp,udp">tcp,udp</option>
              </select>
            </div>
          </div>
        </div>
  
        <!-- Dokodemo-door Settings -->
        <div class="card" v-if="inboundData.protocol==='dokodemo-door'">
          <div class="card-body">
            <h5>Dokodemo-door Settings</h5>
            <div class="mb-3">
              <label class="form-label">Target Address</label>
              <input type="text" class="form-control" v-model="inboundData.settings.address">
            </div>
            <div class="mb-3">
              <label class="form-label">Destination Port</label>
              <input type="number" class="form-control" v-model.number="inboundData.settings.port" min="1" max="65535">
            </div>
            <div class="mb-3">
              <label class="form-label">Network</label>
              <select class="form-select" v-model="inboundData.settings.network">
                <option value="tcp">tcp</option>
                <option value="udp">udp</option>
                <option value="tcp,udp">tcp,udp</option>
              </select>
            </div>
            <div class="form-check form-switch mb-3">
              <input class="form-check-input" type="checkbox" v-model="inboundData.settings.followRedirect">
              <label class="form-check-label">Follow Redirect</label>
            </div>
            <div class="mb-3">
              <label class="form-label">User Level</label>
              <input type="number" class="form-control" v-model.number="inboundData.settings.userLevel">
            </div>
          </div>
        </div>
  
        <!-- Stream Settings (shown for protocols with stream settings only) -->
        <div class="card" v-if="protocolHasStream && inboundData.protocol !== 'dokodemo-door'">
          <div class="card-body">
            <h5>Stream Settings</h5>
            <div class="mb-3">
              <label class="form-label">Transmission Mode</label>
              <select class="form-select" v-model="inboundData.streamSettings.network" @change="updateTransmission">
                <option v-for="t in currentTransmissions" :key="t" :value="t">[[ t ]]</option>
              </select>
            </div>
  
            <!-- TCP/RAW Settings -->
            <div v-if="isRawOrTcp && inboundData.streamSettings.tcpSettings">
              <div class="form-check form-switch mb-3">
                <input class="form-check-input" type="checkbox" v-model="inboundData.streamSettings.tcpSettings.acceptProxyProtocol">
                <label class="form-check-label">Accept Proxy Protocol (TCP)</label>
              </div>
              <div class="mb-3">
                <label class="form-label">Header Type</label>
                <select class="form-select" v-model="inboundData.streamSettings.tcpSettings.header.type">
                  <option value="none">None</option>
                  <option value="http">HTTP</option>
                </select>
              </div>
  
              <!-- HTTP sub-sections (only when header type is "http") -->
              <div v-if="inboundData.streamSettings.tcpSettings.header.type==='http'">
                <div class="card mb-3">
                  <div class="card-body">
                    <h6>HTTP Request Template</h6>
                    <div class="mb-3">
                      <label class="form-label">Version</label>
                      <input type="text" class="form-control" v-model="inboundData.streamSettings.tcpSettings.header.request.version">
                    </div>
                    <div class="mb-3">
                      <label class="form-label">Method</label>
                      <input type="text" class="form-control" v-model="inboundData.streamSettings.tcpSettings.header.request.method">
                    </div>
                    <div class="mb-3">
                      <label class="form-label">Path(s) (comma separated)</label>
                      <input type="text" class="form-control" @input="onHttpRequestPathsChange($event.target.value)" :value="httpRequestPathsJoined">
                    </div>
                    <h6>Headers</h6>
                    <table class="table">
                      <thead>
                        <tr>
                          <th>Header Name</th>
                          <th>Header Value(s)</th>
                          <th>Action</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr v-for="(vals, hname) in inboundData.streamSettings.tcpSettings.header.request.headers" :key="hname">
                          <td>
                            <input type="text" class="form-control" :value="hname" @input="onHttpRequestHeaderNameChange($event.target.value, hname)">
                          </td>
                          <td>
                            <input type="text" class="form-control" :value="vals.join(',')" @input="onHttpRequestHeaderValueChange($event.target.value, hname)">
                          </td>
                          <td>
                            <button type="button" class="btn btn-danger btn-sm" @click="removeHttpRequestHeader(hname)">Remove</button>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                    <button type="button" class="btn btn-primary btn-sm" @click="addHttpRequestHeader">Add Header</button>
                  </div>
                </div>
              </div>
  
              <div v-if="inboundData.streamSettings.tcpSettings.header.type==='http'">
                <div class="card mb-3">
                  <div class="card-body">
                    <h6>HTTP Response Template</h6>
                    <div class="mb-3">
                      <label class="form-label">Version</label>
                      <input type="text" class="form-control" v-model="inboundData.streamSettings.tcpSettings.header.response.version">
                    </div>
                    <div class="mb-3">
                      <label class="form-label">Status</label>
                      <input type="text" class="form-control" v-model="inboundData.streamSettings.tcpSettings.header.response.status">
                    </div>
                    <div class="mb-3">
                      <label class="form-label">Reason</label>
                      <input type="text" class="form-control" v-model="inboundData.streamSettings.tcpSettings.header.response.reason">
                    </div>
                    <h6>Headers</h6>
                    <table class="table">
                      <thead>
                        <tr>
                          <th>Header Name</th>
                          <th>Header Value(s)</th>
                          <th>Action</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr v-for="(vals, hname) in inboundData.streamSettings.tcpSettings.header.response.headers" :key="hname">
                          <td>
                            <input type="text" class="form-control" :value="hname" @input="onHttpResponseHeaderNameChange($event.target.value, hname)">
                          </td>
                          <td>
                            <input type="text" class="form-control" :value="vals.join(',')" @input="onHttpResponseHeaderValueChange($event.target.value, hname)">
                          </td>
                          <td>
                            <button type="button" class="btn btn-danger btn-sm" @click="removeHttpResponseHeader(hname)">Remove</button>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                    <button type="button" class="btn btn-primary btn-sm" @click="addHttpResponseHeader">Add Header</button>
                  </div>
                </div>
              </div>
            </div>
  
            <!-- mKCP Settings -->
            <div v-if="inboundData.streamSettings.network==='mKCP'">
              <div class="card mb-3">
                <div class="card-body">
                  <h5>mKCP Settings</h5>
                  <div class="mb-3">
                    <label class="form-label">MTU</label>
                    <input type="number" class="form-control" v-model.number="inboundData.streamSettings.kcpSettings.mtu">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">TTI (ms)</label>
                    <input type="number" class="form-control" v-model.number="inboundData.streamSettings.kcpSettings.tti">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Uplink Capacity (MB)</label>
                    <input type="number" class="form-control" v-model.number="inboundData.streamSettings.kcpSettings.uplinkCapacity">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Downlink Capacity (MB)</label>
                    <input type="number" class="form-control" v-model.number="inboundData.streamSettings.kcpSettings.downlinkCapacity">
                  </div>
                  <div class="form-check form-switch mb-3">
                    <input class="form-check-input" type="checkbox" v-model="inboundData.streamSettings.kcpSettings.congestion">
                    <label class="form-check-label">Congestion Control</label>
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Read Buffer Size (MB)</label>
                    <input type="number" class="form-control" v-model.number="inboundData.streamSettings.kcpSettings.readBufferSize">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Write Buffer Size (MB)</label>
                    <input type="number" class="form-control" v-model.number="inboundData.streamSettings.kcpSettings.writeBufferSize">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Header Type</label>
                    <select class="form-select" v-model="inboundData.streamSettings.kcpSettings.header.type">
                      <option value="none">None</option>
                      <option value="srtp">SRTP</option>
                      <option value="utp">uTP</option>
                      <option value="wechat-video">WeChat Video</option>
                      <option value="dtls">DTLS</option>
                      <option value="wireguard">WireGuard</option>
                    </select>
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Seed (optional)</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.kcpSettings.seed">
                  </div>
                </div>
              </div>
            </div>
  
            <!-- WS Settings -->
            <div v-if="inboundData.streamSettings.network==='ws'">
              <div class="card mb-3">
                <div class="card-body">
                  <h5>WebSocket Settings</h5>
                  <div class="mb-3">
                    <label class="form-label">Path</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.wsSettings.path">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Host (optional)</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.wsSettings.host">
                  </div>
                </div>
              </div>
            </div>
  
            <!-- gRPC Settings -->
            <div v-if="inboundData.streamSettings.network==='grpc'">
              <div class="card mb-3">
                <div class="card-body">
                  <h5>gRPC Settings</h5>
                  <div class="mb-3">
                    <label class="form-label">Service Name</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.grpcSettings.serviceName">
                  </div>
                  <div class="form-check form-switch mb-3">
                    <input class="form-check-input" type="checkbox" v-model="inboundData.streamSettings.grpcSettings.multiMode">
                    <label class="form-check-label">MultiMode</label>
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Idle Timeout (s)</label>
                    <input type="number" class="form-control" v-model.number="inboundData.streamSettings.grpcSettings.idle_timeout">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Health Check Timeout (s)</label>
                    <input type="number" class="form-control" v-model.number="inboundData.streamSettings.grpcSettings.health_check_timeout">
                  </div>
                  <div class="form-check form-switch mb-3">
                    <input class="form-check-input" type="checkbox" v-model="inboundData.streamSettings.grpcSettings.permit_without_stream">
                    <label class="form-check-label">Permit Without Stream</label>
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Initial Window Size</label>
                    <input type="number" class="form-control" v-model.number="inboundData.streamSettings.grpcSettings.initial_windows_size">
                  </div>
                </div>
              </div>
            </div>
  
            <!-- HTTP Upgrade Settings -->
            <div v-if="inboundData.streamSettings.network==='httpupgrade'">
              <div class="card mb-3">
                <div class="card-body">
                  <h5>HTTP Upgrade Settings</h5>
                  <div class="mb-3">
                    <label class="form-label">Path</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.httpupgradeSettings.path">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Host</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.httpupgradeSettings.host">
                  </div>
                </div>
              </div>
            </div>
  
            <!-- XHTTP Settings -->
            <div v-if="inboundData.streamSettings.network==='xhttp'">
              <div class="card mb-3">
                <div class="card-body">
                  <h5>XHTTP Settings</h5>
                  <div class="mb-3">
                    <label class="form-label">Path</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.xhttpSettings.path">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Host</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.xhttpSettings.host">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Mode</label>
                    <select class="form-select" v-model="inboundData.streamSettings.xhttpSettings.mode">
                      <option value="auto">Auto</option>
                      <option value="packet-up">Packet Up</option>
                      <option value="stream-up">Stream Up</option>
                      <option value="stream-one">Stream One</option>
                    </select>
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Extra Settings (JSON)</label>
                    <textarea class="form-control" rows="4" @input="onXhttpExtraChange($event.target.value)" :value="xhttpExtraText"></textarea>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
  
        <!-- Security Settings -->
        <div class="card" v-if="protocolHasStream">
          <div class="card-body">
            <h5>Security Settings</h5>
            <div class="mb-3">
              <label class="form-label">Security</label>
              <select class="form-select" v-model="inboundData.streamSettings.security" @change="updateSecurity">
                <option v-for="opt in availableSecurityOptions" :key="opt" :value="opt">
                  [[ opt.toUpperCase() ]]
                </option>
              </select>
            </div>
  
            <!-- TLS Settings -->
            <div v-if="inboundData.streamSettings.security==='tls'">
              <div class="card mb-3">
                <div class="card-body">
                  <h6>TLS Settings</h6>
                  <div class="mb-3">
                    <label class="form-label">Server Name</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.tlsSettings.serverName">
                  </div>
                  <div class="form-check form-switch mb-3">
                    <input class="form-check-input" type="checkbox" v-model="inboundData.streamSettings.tlsSettings.rejectUnknownSni">
                    <label class="form-check-label">Reject Unknown SNI</label>
                  </div>
                  <div class="form-check form-switch mb-3">
                    <input class="form-check-input" type="checkbox" v-model="inboundData.streamSettings.tlsSettings.allowInsecure">
                    <label class="form-check-label">Allow Insecure</label>
                  </div>
                  <div class="form-check form-switch mb-3">
                    <input class="form-check-input" type="checkbox" v-model="inboundData.streamSettings.tlsSettings.disableSystemRoot">
                    <label class="form-check-label">Disable System Root</label>
                  </div>
                  <div class="form-check form-switch mb-3">
                    <input class="form-check-input" type="checkbox" v-model="inboundData.streamSettings.tlsSettings.enableSessionResumption">
                    <label class="form-check-label">Enable Session Resumption</label>
                  </div>
                  <div class="mb-3">
                    <label class="form-label">ALPN</label>
                    <select class="form-select" v-model="alpnString">
                      <option value="h2,http/1.1">Default (h2,http/1.1)</option>
                      <option value="http/1.1">HTTP/1.1 Only</option>
                      <option value="h2">H2 Only</option>
                      <option value="h3">H3 Only</option>
                      <option value="h3,h2,http/1.1">H3/H2/HTTP1</option>
                    </select>
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Minimum TLS Version</label>
                    <select class="form-select" v-model="inboundData.streamSettings.tlsSettings.minVersion">
                      <option value="1.0">1.0</option>
                      <option value="1.1">1.1</option>
                      <option value="1.2">1.2</option>
                      <option value="1.3">1.3</option>
                    </select>
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Maximum TLS Version</label>
                    <select class="form-select" v-model="inboundData.streamSettings.tlsSettings.maxVersion">
                      <option value="1.0">1.0</option>
                      <option value="1.1">1.1</option>
                      <option value="1.2">1.2</option>
                      <option value="1.3">1.3</option>
                    </select>
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Cipher Suites</label>
                    <select class="form-select" v-model="inboundData.streamSettings.tlsSettings.cipherSuites">
                      <option value="auto">auto</option>
                      <option>AES 128 GCM</option>
                      <option>AES 256 GCM</option>
                      <option>CHACHA20 POLY1305</option>
                      <option>ECDHE ECDSA AES 128 CBC</option>
                      <option>ECDHE ECDSA AES 256 CBC</option>
                      <option>ECDHE RSA AES 128 CBC</option>
                      <option>ECDHE RSA AES 256 CBC</option>
                      <option>ECDHE ECDSA AES 128 GCM</option>
                      <option>ECDHE ECDSA AES 256 GCM</option>
                      <option>ECDHE RSA AES 128 GCM</option>
                      <option>ECDHE RSA AES 256 GCM</option>
                      <option>ECDHE ECDSA CHACHA20 POLY1305</option>
                      <option>ECDHE RSA CHACHA20 POLY1305</option>
                    </select>
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Fingerprint</label>
                    <select class="form-select" v-model="inboundData.streamSettings.tlsSettings.fingerprint">
                      <option value="chrome">chrome</option>
                      <option value="firefox">firefox</option>
                      <option value="safari">safari</option>
                      <option value="ios">ios</option>
                      <option value="android">android</option>
                      <option value="edge">edge</option>
                      <option value="360">360</option>
                      <option value="qq">qq</option>
                      <option value="random">random</option>
                      <option value="randomized">randomized</option>
                    </select>
                  </div>
  
                  <!-- Certificate Input Mode -->
                  <div class="mb-3">
                    <label class="form-label">Certificate Input Mode:</label>
                    <ul class="nav nav-pills" role="tablist">
                      <li class="nav-item" role="presentation">
                        <button type="button" class="nav-link" :class="{ active: certMode==='file' }" @click="certMode='file'">
                          File Path
                        </button>
                      </li>
                      <li class="nav-item" role="presentation">
                        <button type="button" class="nav-link" :class="{ active: certMode==='content' }" @click="certMode='content'">
                          Direct Content
                        </button>
                      </li>
                    </ul>
                  </div>
  
                  <div v-if="certMode==='file'">
                    <div class="mb-3">
                      <label class="form-label">Certificate File Path</label>
                      <input type="text" class="form-control" v-model="inboundData.streamSettings.tlsSettings.certificateFile">
                    </div>
                    <div class="mb-3">
                      <label class="form-label">Key File Path</label>
                      <input type="text" class="form-control" v-model="inboundData.streamSettings.tlsSettings.keyFile">
                    </div>
                  </div>
                  <div v-if="certMode==='content'">
                    <div class="mb-3">
                      <label class="form-label">Certificate Content</label>
                      <textarea class="form-control" rows="5" v-model="inboundData.streamSettings.tlsSettings.certificate"></textarea>
                    </div>
                    <div class="mb-3">
                      <label class="form-label">Key Content</label>
                      <textarea class="form-control" rows="5" v-model="inboundData.streamSettings.tlsSettings.key"></textarea>
                    </div>
                    <button type="button" class="btn-teal" @click="generateSelfSigned">
                      Generate Self-Signed
                    </button>
                  </div>
                </div>
              </div>
            </div>
  
            <!-- REALITY Settings -->
            <div v-if="inboundData.streamSettings.security==='reality'">
              <div class="card mb-3">
                <div class="card-body">
                  <h6>REALITY Settings</h6>
                  <div class="mb-3">
                    <label class="form-label">xver</label>
                    <input type="number" class="form-control" v-model.number="inboundData.streamSettings.realitySettings.xver">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Fingerprint</label>
                    <select class="form-select" v-model="inboundData.streamSettings.realitySettings.fingerprint">
                      <option value="chrome">chrome</option>
                      <option value="firefox">firefox</option>
                      <option value="safari">safari</option>
                      <option value="ios">ios</option>
                      <option value="android">android</option>
                      <option value="edge">edge</option>
                      <option value="360">360</option>
                      <option value="qq">qq</option>
                      <option value="random">random</option>
                      <option value="randomized">randomized</option>
                    </select>
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Dest</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.realitySettings.dest">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">ServerNames (comma-separated)</label>
                    <input type="text" class="form-control" v-model="realityServerNamesText">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Min Client Ver</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.realitySettings.minClientVer">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Max Client Ver</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.realitySettings.maxClientVer">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Max Time Diff (ms)</label>
                    <input type="number" class="form-control" v-model.number="inboundData.streamSettings.realitySettings.maxTimeDiff">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Short IDs</label>
                    <div class="input-group">
                      <input type="text" class="form-control" v-model="shortIdsText">
                      <button class="btn btn-outline-secondary" type="button" @click="regenerateShortIds">Regenerate</button>
                    </div>
                  </div>
                  <div class="mb-3">
                    <label class="form-label">SpiderX</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.realitySettings.spiderX">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Private Key</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.realitySettings.privateKey">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Public Key</label>
                    <input type="text" class="form-control" v-model="inboundData.streamSettings.realitySettings.publicKey">
                    <button type="button" class="btn-teal mt-2" @click="regenRealityKeys">
                      Regen Keys
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
  
        <!-- Sockopt Settings -->
        <div class="card">
          <div class="card-body">
            <h5>Sockopt Settings</h5>
            <div class="mb-3">
              <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" v-model="enableSockopt">
                <label class="form-check-label">Enable Sockopt</label>
              </div>
            </div>
            <div v-if="enableSockopt">
              <div class="mb-3">
                <label class="form-label">Mark</label>
                <input type="number" class="form-control" v-model.number="inboundData.sockopt.mark">
              </div>
              <div class="mb-3">
                <div class="form-check form-switch mb-2">
                  <input class="form-check-input" type="checkbox" v-model="inboundData.sockopt.tcpFastOpen">
                  <label class="form-check-label">TCP Fast Open</label>
                </div>
                <div class="form-check form-switch mb-2">
                  <input class="form-check-input" type="checkbox" v-model="inboundData.sockopt.acceptProxyProtocol">
                  <label class="form-check-label">Accept Proxy Protocol (Sockopt)</label>
                </div>
                <div class="form-check form-switch mb-2">
                  <input class="form-check-input" type="checkbox" v-model="inboundData.sockopt.tcpMptcp">
                  <label class="form-check-label">TCP MPTCP</label>
                </div>
                <div class="form-check form-switch mb-2" v-if="inboundData.sockopt.tcpMptcp">
                  <input class="form-check-input" type="checkbox" v-model="inboundData.sockopt.tcpNoDelay">
                  <label class="form-check-label">TCP NoDelay</label>
                </div>
              </div>
              <div class="mb-3">
                <label class="form-label">TProxy</label>
                <select class="form-select" v-model="inboundData.sockopt.tproxy">
                  <option value="off">off</option>
                  <option value="redirect">redirect</option>
                  <option value="tproxy">tproxy</option>
                </select>
              </div>
              <div class="mb-3">
                <label class="form-label">Domain Strategy</label>
                <select class="form-select" v-model="inboundData.sockopt.domainStrategy">
                  <option value="AsIs">AsIs</option>
                  <option value="UseIP">UseIP</option>
                  <option value="UseIPv4">UseIPv4</option>
                  <option value="UseIPv6">UseIPv6</option>
                </select>
              </div>
              <div class="mb-3">
                <label class="form-label">Dialer Proxy</label>
                <input type="text" class="form-control" v-model="inboundData.sockopt.dialerProxy">
              </div>
              <div class="mb-3">
                <label class="form-label">TCP Keep Alive Interval (sec)</label>
                <input type="number" class="form-control" v-model.number="inboundData.sockopt.tcpKeepAliveInterval">
              </div>
              <div class="mb-3">
                <label class="form-label">TCP Congestion</label>
                <select class="form-select" v-model="inboundData.sockopt.tcpcongestion">
                  <option value="bbr">bbr</option>
                  <option value="cubic">cubic</option>
                  <option value="reno">reno</option>
                </select>
              </div>
              <div class="mb-3">
                <label class="form-label">Interface</label>
                <input type="text" class="form-control" v-model="inboundData.sockopt.interface">
              </div>
            </div>
          </div>
        </div>
  
        <!-- Fallback Settings (Inside protocol settings) -->
        <div class="card" v-if="showFallback">
          <div class="card-header">
            <h5 class="mb-0">
              Fallback (Inside settings)
              <button class="btn-teal float-end" type="button" data-bs-toggle="collapse" data-bs-target="#fallbackCollapse">
                Toggle
              </button>
            </h5>
          </div>
          <div id="fallbackCollapse" class="collapse">
            <div class="card-body">
              <!-- Fallbacks are stored in inboundData.settings.fallbacks -->
              <div class="mb-3">
                <label class="form-label">Fallback SNI</label>
                <input type="text" class="form-control" v-model="fallback.name">
              </div>
              <div class="mb-3">
                <label class="form-label">Fallback ALPN</label>
                <input type="text" class="form-control" v-model="fallback.alpn">
              </div>
              <div class="mb-3">
                <label class="form-label">Fallback Path</label>
                <input type="text" class="form-control" v-model="fallback.path">
              </div>
              <div class="mb-3">
                <label class="form-label">Fallback Dest (port)</label>
                <input type="number" class="form-control" v-model.number="fallback.dest">
              </div>
              <div class="mb-3">
                <label class="form-label">Fallback xVer</label>
                <input type="number" class="form-control" min="0" max="2" v-model.number="fallback.xver">
              </div>
            </div>
          </div>
        </div>
  
        <!-- Sniffing Settings -->
        <div class="card">
          <div class="card-body">
            <h5>Sniffing</h5>
            <div class="form-check form-switch mb-3">
              <input class="form-check-input" type="checkbox" v-model="inboundData.sniffing.enabled">
              <label class="form-check-label">Enable Sniffing</label>
            </div>
            <div v-if="inboundData.sniffing.enabled">
              <div class="mb-2">Dest Override</div>
              <div class="mb-3">
                <div class="form-check" v-for="doVal in destOverrideOptions" :key="doVal">
                  <input class="form-check-input" type="checkbox" :value="doVal" :checked="inboundData.sniffing.destOverride.includes(doVal)" @change="toggleDestOverride(doVal)">
                  <label class="form-check-label">[[ doVal ]]</label>
                </div>
              </div>
              <div class="form-check form-switch mb-3">
                <input class="form-check-input" type="checkbox" v-model="inboundData.sniffing.metadataOnly">
                <label class="form-check-label">Metadata Only</label>
              </div>
              <div class="form-check form-switch mb-3">
                <input class="form-check-input" type="checkbox" v-model="inboundData.sniffing.routeOnly">
                <label class="form-check-label">Route Only</label>
              </div>
              <div class="mb-3">
                <label class="form-label">Domains Excluded (comma separated)</label>
                <input type="text" class="form-control" @input="onDomainsExcludedChange($event.target.value)" :value="domainsExcludedString">
              </div>
            </div>
          </div>
        </div>
      </div>
  
      <!-- JSON TAB -->
      <div class="tab-pane" :class="[ currentTab==='json' ? 'active show' : '' ]" role="tabpanel" id="jsonTabContent">
        <div class="json-error" v-if="jsonError">[[ jsonError ]]</div>
        <div ref="editorContainer"></div>
      </div>
    </div>
  </div>
  
  <script>
    const defaultTcp = {
      acceptProxyProtocol: false,
      header: {
        type: 'none',
        request: { version: '', method: '', path: [], headers: {} },
        response: { version: '', status: '', reason: '', headers: {} }
      }
    };
    const defaultKcp = {
      mtu: 1350, tti: 50, uplinkCapacity: 5, downlinkCapacity: 20, congestion: false,
      readBufferSize: 2, writeBufferSize: 2, header: { type: 'none' }, seed: ''
    };
    const defaultWs = { path: '/', host: '' };
    const defaultGrpc = {
      serviceName: '', multiMode: false, idle_timeout: 60, health_check_timeout: 20,
      permit_without_stream: false, initial_windows_size: 0
    };
    const defaultHttpupgrade = { path: '/', host: '' };
    const defaultXhttp = { path: '/', host: '', mode: 'auto', extra: {} };
  
    const { createApp } = Vue;
  
    function mergeDeep(target, source) {
      for (const key in source) {
        if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
          if (!target[key]) target[key] = {};
          mergeDeep(target[key], source[key]);
        } else {
          target[key] = source[key];
        }
      }
      return target;
    }
  
    createApp({
      delimiters: ['[[', ']]'],
      data() {
        return {
          page_title: "{{ page_title }}",
          currentTab: 'form',
          jsonError: '',
          editor: null,
          protocols: ['vmess', 'vless', 'trojan', 'shadowsocks', 'dokodemo-door'],
          ssMethods: [
            '2022-blake3-aes-128-gcm', '2022-blake3-aes-256-gcm', '2022-blake3-chacha20-poly1305',
            'aes-256-gcm', 'aes-128-gcm', 'chacha20-poly1305', 'chacha20-ietf-poly1305',
            'xchacha20-poly1305', 'xchacha20-ietf-poly1305', 'none'
          ],
          destOverrideOptions: ['http', 'tls', 'quic', 'fakedns', 'fakedns+others'],
          inboundData: {
            tag: '',
            listen: '0.0.0.0',
            port: Math.floor(Math.random() * (65535 - 10000 + 1)) + 10000,
            protocol: 'vmess',
            settings: {},
            streamSettings: {
              network: 'tcp',
              security: 'none',
              tcpSettings: JSON.parse(JSON.stringify(defaultTcp))
            },
            sniffing: {
              enabled: false,
              destOverride: ['http', 'tls', 'quic', 'fakedns'],
              metadataOnly: false,
              routeOnly: false,
              domainsExcluded: []
            }
          },
          fullInboundData: {},
          certMode: 'file',
          isInitialized: false
        }
      },
      computed: {
        protocolHasStream() {
          return (['vmess', 'vless', 'trojan', 'shadowsocks'].includes(this.inboundData.protocol));
        },
        currentTransmissions() {
          const map = {
            vmess: ['raw', 'tcp', 'mKCP', 'ws', 'grpc', 'httpupgrade', 'xhttp'],
            vless: ['raw', 'tcp', 'mKCP', 'ws', 'grpc', 'httpupgrade', 'xhttp'],
            trojan: ['raw', 'tcp', 'mKCP', 'ws', 'grpc', 'httpupgrade', 'xhttp'],
            shadowsocks: ['tcp', 'udp', 'tcp,udp', 'raw', 'mKCP', 'ws', 'grpc', 'httpupgrade', 'xhttp'],
            "dokodemo-door": []
          };
          return map[this.inboundData.protocol] || [];
        },
        isRawOrTcp() {
          const n = this.inboundData.streamSettings.network;
          return (n === 'raw' || n === 'tcp');
        },
        availableSecurityOptions() {
          const n = this.inboundData.streamSettings.network;
          switch (n) {
            case 'tcp':
            case 'raw':
              return ['none', 'tls', 'reality'];
            case 'mKCP':
              return ['none'];
            case 'ws':
              return ['none', 'tls'];
            case 'grpc':
              return ['none', 'tls', 'reality'];
            case 'httpupgrade':
              return ['none', 'tls'];
            case 'xhttp':
              return ['none', 'tls', 'reality'];
            default:
              return ['none'];
          }
        },
        enableSockopt: {
          get() {
            return !!this.inboundData.sockopt;
          },
          set(val) {
            if (!val) {
              this.inboundData.sockopt = null;
            } else {
              if (!this.inboundData.sockopt) {
                this.inboundData.sockopt = {
                  mark: 0,
                  tcpFastOpen: false,
                  acceptProxyProtocol: false,
                  tcpMptcp: false,
                  tcpNoDelay: false,
                  tproxy: 'off',
                  domainStrategy: 'AsIs',
                  dialerProxy: '',
                  tcpKeepAliveInterval: 0,
                  tcpcongestion: 'bbr',
                  interface: ''
                };
              }
            }
          }
        },
        fallback() {
          if (this.inboundData.protocol === 'vless' || this.inboundData.protocol === 'trojan') {
            if (!this.inboundData.settings) this.inboundData.settings = {};
            if (!this.inboundData.settings.fallbacks) this.inboundData.settings.fallbacks = [];
            if (this.inboundData.settings.fallbacks.length === 0) {
              this.inboundData.settings.fallbacks.push({ dest: '', name: '', alpn: '', path: '', xver: '' });
            }
            return this.inboundData.settings.fallbacks[0];
          }
          return null;
        },
        showFallback() {
          return ((this.inboundData.protocol === 'vless' || this.inboundData.protocol === 'trojan') &&
                  this.inboundData.streamSettings.network === 'tcp');
        },
        httpRequestPathsJoined() {
          const arr = this.inboundData.streamSettings.tcpSettings?.header?.request?.path || [];
          return arr.join(',');
        },
        xhttpExtraText() {
          try {
            return JSON.stringify(this.inboundData.streamSettings.xhttpSettings.extra, null, 2);
          } catch (e) {
            return '';
          }
        },
        alpnString: {
          get() {
            return (this.inboundData.streamSettings.tlsSettings.alpn || []).join(',');
          },
          set(val) {
            this.inboundData.streamSettings.tlsSettings.alpn = val.split(',').map(x => x.trim()).filter(Boolean);
          }
        },
        shortIdsText: {
          get() {
            return (this.inboundData.streamSettings.realitySettings?.shortIds || []).join(',');
          },
          set(val) {
            this.inboundData.streamSettings.realitySettings.shortIds = val.split(',').map(x => x.trim()).filter(Boolean);
          }
        },
        realityServerNamesText: {
          get() {
            return (this.inboundData.streamSettings.realitySettings?.serverNames || []).join(',');
          },
          set(val) {
            this.inboundData.streamSettings.realitySettings.serverNames = val.split(',').map(x => x.trim()).filter(Boolean);
          }
        },
        domainsExcludedString() {
          return (this.inboundData.sniffing.domainsExcluded || []).join(',');
        }
      },
      watch: {
        'inboundData.protocol'(newVal) {
          if (newVal === 'shadowsocks') {
            if (!this.inboundData.settings || Object.keys(this.inboundData.settings).length === 0) {
              this.inboundData.settings = {
                method: "2022-blake3-aes-128-gcm",
                password: "",
                network: "tcp,udp",
                clients: [],
                ivCheck: false
              };
              this.regenerateSSPassword();
            }
          } else if (newVal === 'dokodemo-door') {
            this.inboundData.settings = {
              address: "",
              port: this.inboundData.port,
              network: "tcp",
              followRedirect: false,
              userLevel: 0
            };
          }
        }
      },
      mounted() {
        this.currentTab = 'form';
        if (window.initialInboundData && Object.keys(window.initialInboundData).length > 0) {
          this.fullInboundData = JSON.parse(JSON.stringify(window.initialInboundData));
          this.inboundData = this.normalizeInboundData(JSON.parse(JSON.stringify(window.initialInboundData)));
          if (this.inboundData.streamSettings && this.inboundData.streamSettings.tlsSettings) {
            if (this.inboundData.streamSettings.tlsSettings.certificate && this.inboundData.streamSettings.tlsSettings.certificate.trim() !== "") {
              this.certMode = 'content';
            } else if (this.inboundData.streamSettings.tlsSettings.certificateFile && this.inboundData.streamSettings.tlsSettings.certificateFile.trim() !== "") {
              this.certMode = 'file';
            }
          }
        }
        this.initEditor();
        this.isInitialized = true;
        window.submitInboundForm = this.submitInboundForm;
      },
      methods: {
        mergeDeep,
        normalizeInboundData(obj) {
          const clone = JSON.parse(JSON.stringify(obj));
          if (!clone.streamSettings) {
            clone.streamSettings = JSON.parse(JSON.stringify(this.inboundData.streamSettings));
          }
          if (!clone.sniffing) {
            clone.sniffing = JSON.parse(JSON.stringify(this.inboundData.sniffing));
          }
          if (clone.streamSettings && !clone.streamSettings.tcpSettings &&
              (clone.streamSettings.network === 'tcp' || clone.streamSettings.network === 'raw')) {
            clone.streamSettings.tcpSettings = JSON.parse(JSON.stringify(defaultTcp));
          }
          if (clone.streamSettings && clone.streamSettings.security === 'reality' &&
              clone.streamSettings.realitySettings && clone.streamSettings.realitySettings.serverName) {
            delete clone.streamSettings.realitySettings.serverName;
          }
          return clone;
        },
        getCleanConfig() {
          let config = mergeDeep(JSON.parse(JSON.stringify(this.fullInboundData)), this.inboundData);
          if (!config.sockopt || (typeof config.sockopt === 'object' && Object.keys(config.sockopt).length === 0)) {
            delete config.sockopt;
          }
          if (config.streamSettings && config.streamSettings.tcpSettings &&
              config.streamSettings.tcpSettings.header &&
              config.streamSettings.tcpSettings.header.type === 'none') {
            delete config.streamSettings.tcpSettings.header.request;
            delete config.streamSettings.tcpSettings.header.response;
          }
          if (config.protocol === 'dokodemo-door') {
            delete config.streamSettings;
          }
          if (!(config.protocol === 'vless' || config.protocol === 'trojan') ||
              !config.streamSettings || config.streamSettings.network !== 'tcp') {
            if (config.settings) {
              delete config.settings.fallbacks;
            }
          } else {
            if (config.settings && Array.isArray(config.settings.fallbacks) && config.settings.fallbacks.length > 0) {
              const fb = config.settings.fallbacks[0];
              let hasValue = false;
              const cleanFallback = {};
              for (const key in fb) {
                if (fb[key] !== '' && fb[key] !== 0 && fb[key] !== null && fb[key] !== undefined) {
                  hasValue = true;
                  cleanFallback[key] = fb[key];
                }
              }
              if (hasValue) {
                config.settings.fallbacks = [cleanFallback];
              } else {
                delete config.settings.fallbacks;
              }
            } else if (config.settings) {
              delete config.settings.fallbacks;
            }
          }
          return config;
        },
        initEditor() {
          this.editor = CodeMirror(this.$refs.editorContainer, {
            lineNumbers: true,
            mode: 'application/json',
            theme: 'dracula',
            value: JSON.stringify(this.getCleanConfig(), null, 2),
            viewportMargin: Infinity
          });
          this.editor.on('change', cm => {
            try {
              const raw = cm.getValue();
              this.fullInboundData = JSON.parse(raw);
              this.jsonError = '';
            } catch (e) {
              this.jsonError = 'JSON parse error: ' + e.message;
            }
          });
          this.editor.refresh();
        },
        switchTab(tab) {
          this.currentTab = tab;
          if (tab === 'json') {
            this.$nextTick(() => {
              this.fullInboundData = this.getCleanConfig();
              if (this.editor) {
                this.editor.setValue(JSON.stringify(this.fullInboundData, null, 2));
                this.editor.refresh();
              }
            });
          } else if (tab === 'form') {
            this.$nextTick(() => {
              this.inboundData = this.normalizeInboundData(this.fullInboundData);
            });
          }
        },
        updateTransmission() {
          const nVal = this.inboundData.streamSettings.network;
          delete this.inboundData.streamSettings.tcpSettings;
          delete this.inboundData.streamSettings.kcpSettings;
          delete this.inboundData.streamSettings.wsSettings;
          delete this.inboundData.streamSettings.grpcSettings;
          delete this.inboundData.streamSettings.httpupgradeSettings;
          delete this.inboundData.streamSettings.xhttpSettings;
          if (nVal === 'tcp' || nVal === 'raw') {
            this.inboundData.streamSettings.tcpSettings = JSON.parse(JSON.stringify(defaultTcp));
          } else if (nVal === 'mKCP') {
            this.inboundData.streamSettings.kcpSettings = JSON.parse(JSON.stringify(defaultKcp));
          } else if (nVal === 'ws') {
            this.inboundData.streamSettings.wsSettings = JSON.parse(JSON.stringify(defaultWs));
          } else if (nVal === 'grpc') {
            this.inboundData.streamSettings.grpcSettings = JSON.parse(JSON.stringify(defaultGrpc));
          } else if (nVal === 'httpupgrade') {
            this.inboundData.streamSettings.httpupgradeSettings = JSON.parse(JSON.stringify(defaultHttpupgrade));
          } else if (nVal === 'xhttp') {
            this.inboundData.streamSettings.xhttpSettings = JSON.parse(JSON.stringify(defaultXhttp));
          }
        },
        updateSecurity() {
          const nVal = this.inboundData.streamSettings.security;
          delete this.inboundData.streamSettings.tlsSettings;
          delete this.inboundData.streamSettings.realitySettings;
          if (nVal === 'tls') {
            this.inboundData.streamSettings.tlsSettings = {
              serverName: 'xray.com',
              rejectUnknownSni: false,
              allowInsecure: false,
              disableSystemRoot: false,
              enableSessionResumption: false,
              alpn: [],
              minVersion: '1.2',
              maxVersion: '1.3',
              cipherSuites: 'auto',
              fingerprint: 'chrome',
              certificateFile: '',
              keyFile: '',
              certificate: '',
              key: ''
            };
          } else if (nVal === 'reality') {
            this.inboundData.streamSettings.realitySettings = {
              dest: 'example.com:443',
              xver: 0,
              fingerprint: 'chrome',
              maxTimeDiff: 0,
              shortIds: this.generateShortIdsArray(),
              spiderX: '/',
              privateKey: '',
              publicKey: '',
              minClientVer: '',
              maxClientVer: '',
              serverNames: []
            };
          }
        },
        regenerateSSPassword() {
          const method = this.inboundData.settings.method;
          let password;

          if (method === '2022-blake3-aes-128-gcm') {
            password = generateBase64Password(16);
          } else if (method === '2022-blake3-aes-256-gcm' || method === '2022-blake3-chacha20-poly1305') {
            password = generateBase64Password(32);
          } else {
            password = generateAlphanumericPassword(40);
          }

          this.inboundData.settings.password = password;
        },
        submitInboundForm() {
          if (!this.inboundData.tag || !this.inboundData.tag.trim()) {
            alert('Cannot save inbound without a tag!');
            return;
          }
          const finalConfig = this.getCleanConfig();
          const fd = new FormData();
          fd.append('remark', finalConfig.tag);
          fd.append('listen', finalConfig.listen || '0.0.0.0');
          fd.append('port', String(finalConfig.port || '0'));
          fd.append('protocol', finalConfig.protocol);
          if (finalConfig.protocol === 'shadowsocks') {
            fd.append('ss_method', finalConfig.settings.method || '');
            fd.append('ss_password', finalConfig.settings.password || '');
            fd.append('ss_network', finalConfig.settings.network || 'tcp,udp');
            fd.append('ivCheck', finalConfig.settings.ivCheck ? 'on' : 'off');
          }
          if (finalConfig.protocol === 'dokodemo-door') {
            fd.append('dokodemo_address', finalConfig.settings.address || '');
            fd.append('dokodemo_port', String(finalConfig.settings.port || finalConfig.port));
            fd.append('dokodemo_network', finalConfig.settings.network || 'tcp');
            fd.append('follow_redirect', finalConfig.settings.followRedirect ? 'on' : 'off');
            fd.append('user_level', String(finalConfig.settings.userLevel || 0));
          }
          let security = 'none';
          let transmission = 'tcp';
          if (this.protocolHasStream) {
            security = finalConfig.streamSettings.security || 'none';
            transmission = finalConfig.streamSettings.network || 'tcp';
          } else if (finalConfig.protocol === 'shadowsocks') {
            transmission = finalConfig.settings.network || 'tcp,udp';
          }
          fd.append('security', security);
          fd.append('transmission', transmission);
          if (transmission === 'tcp' || transmission === 'raw') {
            const tcp = finalConfig.streamSettings.tcpSettings;
            if (tcp && tcp.acceptProxyProtocol) {
              fd.append('accept_proxy', 'on');
            }
            const headerType = tcp?.header?.type || 'none';
            fd.append('header_type', headerType);
            if (headerType === 'http') {
              const rq = tcp.header.request;
              fd.append('http_request_version', rq.version || '1.1');
              fd.append('http_request_method', rq.method || 'GET');
              fd.append('http_request_paths', (rq.path || ['/']).join(','));
              const rqNames = [];
              const rqValues = [];
              for (const hname in rq.headers) {
                rqNames.push(hname);
                rqValues.push(rq.headers[hname].join(','));
              }
              rqNames.forEach((n, i) => {
                fd.append('http_request_header_name[]', n);
                fd.append('http_request_header_value[]', rqValues[i]);
              });
              const rp = tcp.header.response;
              fd.append('http_response_version', rp.version || '1.1');
              fd.append('http_response_status', rp.status || '200');
              fd.append('http_response_reason', rp.reason || 'OK');
              const rpNames = [];
              const rpValues = [];
              for (const hname in rp.headers) {
                rpNames.push(hname);
                rpValues.push(rp.headers[hname].join(','));
              }
              rpNames.forEach((n, i) => {
                fd.append('http_response_header_name[]', n);
                fd.append('http_response_header_value[]', rpValues[i]);
              });
            }
          }
          if (transmission === 'mKCP') {
            const kc = finalConfig.streamSettings.kcpSettings;
            fd.append('kcp_mtu', String(kc.mtu || '1350'));
            fd.append('kcp_tti', String(kc.tti || '50'));
            fd.append('kcp_uplink', String(kc.uplinkCapacity || '5'));
            fd.append('kcp_downlink', String(kc.downlinkCapacity || '20'));
            if (kc.congestion) fd.append('kcp_congestion', 'on');
            fd.append('kcp_read_buffer', String(kc.readBufferSize || '2'));
            fd.append('kcp_write_buffer', String(kc.writeBufferSize || '2'));
            fd.append('kcp_header', kc.header?.type || 'none');
            if (kc.seed) fd.append('kcp_seed', kc.seed);
          }
          if (transmission === 'ws') {
            const ws = finalConfig.streamSettings.wsSettings;
            fd.append('ws_path', ws.path || '/');
            fd.append('ws_host', ws.host || '');
          }
          if (transmission === 'grpc') {
            const g = finalConfig.streamSettings.grpcSettings;
            fd.append('grpc_service', g.serviceName || '');
            if (g.multiMode) fd.append('grpc_multiMode', 'on');
            fd.append('grpc_idle_timeout', String(g.idle_timeout || '60'));
            fd.append('grpc_health_check_timeout', String(g.health_check_timeout || '20'));
            if (g.permit_without_stream) fd.append('grpc_permit_without_stream', 'on');
            fd.append('grpc_initial_windows_size', String(g.initial_windows_size || '0'));
          }
          if (transmission === 'httpupgrade') {
            const hu = finalConfig.streamSettings.httpupgradeSettings;
            fd.append('httpupgrade_path', hu.path || '/');
            fd.append('httpupgrade_host', hu.host || '');
          }
          if (transmission === 'xhttp') {
            const xh = finalConfig.streamSettings.xhttpSettings;
            fd.append('xhttp_path', xh.path || '/');
            fd.append('xhttp_host', xh.host || '');
            fd.append('xhttp_mode', xh.mode || 'auto');
            fd.append('xhttp_extra', JSON.stringify(xh.extra || {}));
          }
          if (security === 'tls') {
            const tls = finalConfig.streamSettings.tlsSettings;
            fd.append('tls_serverName', tls.serverName || 'xray.com');
            if (tls.rejectUnknownSni) fd.append('reject_unknown_sni', 'on');
            if (tls.allowInsecure) fd.append('allow_insecure', 'on');
            if (tls.disableSystemRoot) fd.append('disable_system_root', 'on');
            if (tls.enableSessionResumption) fd.append('enable_session_resumption', 'on');
            fd.append('alpn', (tls.alpn || ['h2', 'http/1.1']).join(','));
            fd.append('min_version', tls.minVersion || '1.2');
            fd.append('max_version', tls.maxVersion || '1.3');
            fd.append('cipher_suites', tls.cipherSuites || 'auto');
            fd.append('tls_fingerprint', tls.fingerprint || 'chrome');
            if (this.certMode === 'file') {
              fd.append('cert_mode', 'file');
              fd.append('cert_file_path', tls.certificateFile || '');
              fd.append('key_file_path', tls.keyFile || '');
            } else {
              fd.append('cert_mode', 'content');
              fd.append('cert_content', tls.certificate || '');
              fd.append('key_content', tls.key || '');
            }
          }
          if (security === 'reality') {
            const r = finalConfig.streamSettings.realitySettings;
            fd.append('reality_dest', r.dest || 'example.com:443');
            fd.append('reality_serverNames', (r.serverNames || []).join(','));
            fd.append('reality_xver', String(r.xver || '0'));
            fd.append('reality_fingerprint', r.fingerprint || 'chrome');
            fd.append('reality_minClientVer', r.minClientVer || '');
            fd.append('reality_maxClientVer', r.maxClientVer || '');
            fd.append('reality_maxTimeDiff', String(r.maxTimeDiff || '0'));
            fd.append('reality_shortIds', (r.shortIds || []).join(','));
            fd.append('reality_spiderX', r.spiderX || '/');
            fd.append('reality_privateKey', r.privateKey || '');
            fd.append('reality_publicKey', r.publicKey || '');
          }
          if (finalConfig.settings && finalConfig.settings.fallbacks) {
            finalConfig.settings.fallbacks.forEach(fb => {
              for (const key in fb) {
                fd.append(`fallback_${key}`, fb[key]);
              }
            });
          }
          if (finalConfig.sniffing && finalConfig.sniffing.enabled) {
            fd.append('sniffing', 'on');
            (finalConfig.sniffing.destOverride || []).forEach(ov => {
              fd.append('dest_override[]', ov);
            });
            if (finalConfig.sniffing.metadataOnly) fd.append('metadata_only', 'on');
            if (finalConfig.sniffing.routeOnly) fd.append('route_only', 'on');
            fd.append('domains_excluded', (finalConfig.sniffing.domainsExcluded || []).join(','));
          }
          fetch(window.formActionUrl, {
            method: 'POST',
            body: fd
          }).then(resp => {
            if (!resp.ok && (resp.status < 200 || resp.status >= 400)) {
              throw new Error('Server responded with status ' + resp.status);
            }
            window.parent.postMessage({ type: "inboundSaved", message: "Inbound saved successfully!" }, "*");
          }).catch(err => {
            alert('Failed to save inbound: ' + err.message);
          });
        },
        onHttpRequestPathsChange(val) {
          const arr = val.split(',').map(x => x.trim()).filter(Boolean);
          this.inboundData.streamSettings.tcpSettings.header.request.path = arr;
        },
        addHttpRequestHeader() {
          this.inboundData.streamSettings.tcpSettings.header.request.headers[''] = [''];
        },
        removeHttpRequestHeader(h) {
          delete this.inboundData.streamSettings.tcpSettings.header.request.headers[h];
        },
        onHttpRequestHeaderNameChange(newN, oldN) {
          const v = this.inboundData.streamSettings.tcpSettings.header.request.headers[oldN];
          delete this.inboundData.streamSettings.tcpSettings.header.request.headers[oldN];
          this.inboundData.streamSettings.tcpSettings.header.request.headers[newN] = v;
        },
        onHttpRequestHeaderValueChange(val, h) {
          const arr = val.split(',').map(x => x.trim()).filter(Boolean);
          this.inboundData.streamSettings.tcpSettings.header.request.headers[h] = arr;
        },
        addHttpResponseHeader() {
          this.inboundData.streamSettings.tcpSettings.header.response.headers[''] = [''];
        },
        removeHttpResponseHeader(h) {
          delete this.inboundData.streamSettings.tcpSettings.header.response.headers[h];
        },
        onHttpResponseHeaderNameChange(newN, oldN) {
          const v = this.inboundData.streamSettings.tcpSettings.header.response.headers[oldN];
          delete this.inboundData.streamSettings.tcpSettings.header.response.headers[oldN];
          this.inboundData.streamSettings.tcpSettings.header.response.headers[newN] = v;
        },
        onHttpResponseHeaderValueChange(val, h) {
          const arr = val.split(',').map(x => x.trim()).filter(Boolean);
          this.inboundData.streamSettings.tcpSettings.header.response.headers[h] = arr;
        },
        onXhttpExtraChange(val) {
          try {
            this.inboundData.streamSettings.xhttpSettings.extra = JSON.parse(val);
          } catch (e) {}
        },
        toggleDestOverride(val) {
          const arr = this.inboundData.sniffing.destOverride;
          const idx = arr.indexOf(val);
          if (idx >= 0) arr.splice(idx, 1);
          else arr.push(val);
        },
        onDomainsExcludedChange(val) {
          const arr = val.split(',').map(x => x.trim()).filter(Boolean);
          this.inboundData.sniffing.domainsExcluded = arr;
        },
        generateSelfSigned() {
          fetch('/generate_cert', { method: 'POST' })
          .then(r => r.json())
          .then(j => {
            if (j.certificate && j.private_key) {
              this.inboundData.streamSettings.tlsSettings.certificate = j.certificate;
              this.inboundData.streamSettings.tlsSettings.key = j.private_key;
              this.certMode = 'content';
              alert('Self-signed cert inserted!');
            } else {
              alert('Unexpected response from /generate_cert');
            }
          })
          .catch(e => alert('Error generating cert: ' + e.message));
        },
        regenRealityKeys() {
          fetch('/generate_reality_keys', { method: 'POST' })
          .then(r => r.json())
          .then(j => {
            if (j.private_key && j.public_key) {
              this.inboundData.streamSettings.realitySettings.privateKey = j.private_key;
              this.inboundData.streamSettings.realitySettings.publicKey = j.public_key;
              alert('Reality keys inserted!');
            } else {
              alert('Unexpected response from /generate_reality_keys');
            }
          })
          .catch(e => alert('Error generating reality keys: ' + e.message));
        },
        generateHexString(length) {
          const byteLength = length / 2;
          const array = new Uint8Array(byteLength);
          crypto.getRandomValues(array);
          return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
        },
        generateShortIdsArray() {
          const lengths = [2, 4, 6, 8, 10, 12, 14, 16];
          const shortIds = [];
          for (let i = 0; i < 8; i++) {
            const randomLength = lengths[Math.floor(Math.random() * lengths.length)];
            const hexString = this.generateHexString(randomLength);
            shortIds.push(hexString);
          }
          return shortIds;
        },
        regenerateShortIds() {
          if (this.inboundData.streamSettings && this.inboundData.streamSettings.realitySettings) {
            this.inboundData.streamSettings.realitySettings.shortIds = this.generateShortIdsArray();
          }
        }
      }
    }).mount('#app');
  </script>
  
</body>
</html>
